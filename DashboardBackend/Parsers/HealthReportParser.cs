using DashboardBackend.Database.Models;
using Model;

namespace DashboardBackend.Parsers
{
    /// <summary>
    /// Converts a list of <see cref="HealthReportEntry"/> which is generated by EFCore into a <see cref="HealthReport"/> which is a model created for the Dashboard system.
    /// </summary>
    public class HealthReportParser : IDataParser<HealthReportEntry, HealthReport>
    {
        /// <inheritdoc/>
        /// <remarks>The data is parsed sequentially since this will ensure that if the host machine is changed (i.e., the total amount of RAM), it will only affect new readings.</remarks>
        /// <returns>A new <see cref="HealthReport"/> containing the result of parsing the specified data.</returns>
        public HealthReport Parse(List<HealthReportEntry> data)
        {
            HealthReport result = new();
            foreach (var entry in data)
            {
                switch (entry.ReportType)
                {
                    #region Host info
                    case "INIT" when entry.ReportKey == "Hostname":
                        result.HostName = entry.ReportStringValue;
                        break;
                    case "INIT" when entry.ReportKey == "Monitor Name":
                        result.MonitorName = entry.ReportStringValue;
                        break;
                    #endregion
                    #region CPU info
                    case "CPU_INIT" when entry.ReportKey == "CPU Name":
                        result.Cpu.Name = entry.ReportStringValue;
                        break;
                    case "CPU_INIT" when entry.ReportKey == "PhysicalCores":
                        result.Cpu.Cores = Convert.ToInt32(entry.ReportNumericValue ?? 0);
                        break;
                    case "CPU_INIT" when entry.ReportKey == "CPU Max frequency":
                        result.Cpu.MaxFrequency = Convert.ToInt64(entry.ReportNumericValue ?? 0);
                        break;
                    #endregion
                    #region CPU data
                    case "CPU" when entry.ReportKey == "LOAD":
                        result.Cpu.Readings.Add(GetCpuReading(entry));
                        break;
                    #endregion
                    #region RAM info
                    case "MEMORY_INIT" when entry.ReportKey == "TOTAL":
                        result.Ram.Total = entry.ReportNumericValue;
                        break;
                    #endregion
                    #region RAM data
                    case "MEMORY" when entry.ReportKey == "AVAILABLE":
                        result.Ram.AddReading(GetRamReading(entry));
                        break;
                    #endregion
                    #region Network info
                    case "NETWORK_INIT" when entry.ReportKey == "Interface 0: Name":
                        result.Network.Name = entry.ReportStringValue;
                        break;
                    case "NETWORK_INIT" when entry.ReportKey == "Interface 0: MAC address":
                        result.Network.MacAddress = entry.ReportStringValue;
                        break;
                    case "NETWORK_INIT" when entry.ReportKey == "Interface 0: Speed":
                        result.Network.Speed = entry.ReportNumericValue ?? 0;
                        break;
                    #endregion
                    #region Network data
                    case "NETWORK" when entry.ReportKey == "Interface 0: Bytes Send":
                        var reading = result.Network.Readings.FirstOrDefault(r => r.BytesSend is null && r.Date.Subtract(entry.LogTime.Value) < TimeSpan.FromSeconds(1));
                        if (reading is null)
                        {
                            reading = new()
                            {
                                ExecutionId = entry.ExecutionId.Value,
                                Date = entry.LogTime.Value,
                            };
                            result.Network.Readings.Add(reading);
                        }
                        reading.BytesSend = entry.ReportNumericValue;
                        break;
                    case "NETWORK" when entry.ReportKey == "Interface 0: Bytes Received":
                        reading = result.Network.Readings.FirstOrDefault(r => r.BytesReceived is null && r.Date.Subtract(entry.LogTime.Value) < TimeSpan.FromSeconds(1));
                        if (reading is null)
                        {
                            reading = new()
                            {
                                ExecutionId = entry.ExecutionId.Value,
                                Date = entry.LogTime.Value,
                            };
                            result.Network.Readings.Add(reading);
                        }
                        reading.BytesReceived = entry.ReportNumericValue;
                        break;
                    case "NETWORK" when entry.ReportKey == "Interface 0: Bytes Send (Delta)":
                        reading = result.Network.Readings.FirstOrDefault(r => r.BytesSendDelta is null && r.Date.Subtract(entry.LogTime.Value) < TimeSpan.FromSeconds(1));
                        if (reading is null)
                        {
                            reading = new()
                            {
                                ExecutionId = entry.ExecutionId.Value,
                                Date = entry.LogTime.Value,
                            };
                            result.Network.Readings.Add(reading);
                        }
                        reading.BytesSendDelta = entry.ReportNumericValue;
                        break;
                    case "NETWORK" when entry.ReportKey == "Interface 0: Bytes Received (Delta)":
                        reading = result.Network.Readings.FirstOrDefault(r => r.BytesReceivedDelta is null && r.Date.Subtract(entry.LogTime.Value) < TimeSpan.FromSeconds(1));
                        if (reading is null)
                        {
                            reading = new()
                            {
                                ExecutionId = entry.ExecutionId.Value,
                                Date = entry.LogTime.Value,
                            };
                            result.Network.Readings.Add(reading);
                        }
                        reading.BytesReceivedDelta = entry.ReportNumericValue.Value;
                        break;
                    case "NETWORK" when entry.ReportKey == "Interface 0: Bytes Send (Speed)":
                        reading = result.Network.Readings.FirstOrDefault(r => r.BytesSendSpeed is null && r.Date.Subtract(entry.LogTime.Value) < TimeSpan.FromSeconds(1));
                        if (reading is null)
                        {
                            reading = new()
                            {
                                ExecutionId = entry.ExecutionId.Value,
                                Date = entry.LogTime.Value,
                            };
                            result.Network.Readings.Add(reading);
                        }
                        reading.BytesSendSpeed = entry.ReportNumericValue.Value;
                        break;
                    case "NETWORK" when entry.ReportKey == "Interface 0: Bytes Received (Speed)":
                        reading = result.Network.Readings.FirstOrDefault(r => r.BytesReceivedSpeed is null && r.Date.Subtract(entry.LogTime.Value) < TimeSpan.FromSeconds(1));
                        if (reading is null)
                        {
                            reading = new()
                            {
                                ExecutionId = entry.ExecutionId.Value,
                                Date = entry.LogTime.Value,
                            };
                            result.Network.Readings.Add(reading);
                        }
                        reading.BytesReceivedSpeed = entry.ReportNumericValue.Value;
                        break;
                    #endregion
                    default:
                        break;
                }
            }
            return result;
        }

        /// <summary>
        /// Creates a <see cref="CpuLoad"/> from the specified <see cref="HealthReportEntry"/>.
        /// </summary>
        /// <param name="item">An entry with a CPU load-reading.</param>
        /// <returns>A CPU load-reading.</returns>
        private static CpuLoad GetCpuReading(HealthReportEntry item)
        {
            int executionId = item.ExecutionId.Value;
            double reportNumValue = Convert.ToDouble(item.ReportNumericValue) / 100;
            DateTime logTime = item.LogTime.Value;
            CpuLoad cpuReading = new(executionId, reportNumValue, logTime);
            return cpuReading;
        }

        /// <summary>
        /// Creates a <see cref="RamLoad"/> from the specified <see cref="HealthReportEntry"/>.
        /// </summary>
        /// <remarks>The actual load is calculated once the reading is added to the <see cref="HealthReport"/>, since it is based on its total RAM.</remarks>
        /// <param name="item">An entry with a RAM (/MEMORY) load-reading.</param>
        /// <param name="item">An entry with a RAM (/MEMORY) load-reading.</param>
        private static RamLoad GetRamReading(HealthReportEntry item)
        {
            int executionId = item.ExecutionId.Value;
            long available = item.ReportNumericValue.Value;
            DateTime logTime = item.LogTime.Value;
            RamLoad ramReading = new(executionId, available, logTime);
            return ramReading;
        }
    }
}
