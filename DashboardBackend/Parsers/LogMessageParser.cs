using System.Text.RegularExpressions;
using DashboardBackend.Database.Models;
using Model;
using static Model.Execution;
using static Model.LogMessage;
using static Model.Manager;

namespace DashboardBackend.Parsers
{
    /// <summary>
    /// Converts a list of <see cref="LoggingEntry"/> which is generated by EFCore into a tuple of <see cref="LogMessage"/>, <see cref="Manager"/> and <see cref="Execution"/>, which are models created for the Dashboard system.
    /// </summary>
    public class LogMessageParser : IDataParser<LoggingEntry, Tuple<List<LogMessage>, List<Manager>, List<Execution>>>
    {
        // Log messages that indicate the end of an execution.
        public List<string> ExecutionFinishedMessages { get; } = new()
        {
            "Program closing due to the following error:",
            "Exiting from GuiManager...",
            "No managers left to start automatically for BATCH",
            "Deploy is finished!!",
        };

        /// <inheritdoc/>
        /// <remarks>Since the logging entries provide information about an execution in its entirety, this method may also create executions and managers along with the log messages.</remarks>
        /// <returns>A tuple containing, mainly, a list of <see cref="LogMessage"/> objects, and secondarily, lists of <see cref="Manager"/> and <see cref="Execution"/> objects.</returns>
        public Tuple<List<LogMessage>, List<Manager>, List<Execution>> Parse(List<LoggingEntry> data)
        {
            List<LogMessage> messages = new();
            List<Manager> managers = new();
            List<Execution> executions = new();

            foreach (LoggingEntry entry in data)
            {
                // Get the parsed message
                LogMessage message = GetParsedLogMessage(entry);
                messages.Add(message);
                // Ensure that an execution is created with the specified ID
                Execution execution = executions.FirstOrDefault(e => e?.Id == message.ExecutionId);
                if (execution is null)
                {
                    execution = new(message.ExecutionId, message.Date);
                    executions.Add(execution);
                }
                if (ExecutionFinishedMessages.Contains(message.Content))
                {
                    execution.Status = ExecutionStatus.Finished;
                }
                // Ensure that a manager is created with the specified context ID
                if (message.ContextId > 0)
                {
                    if (message.Content.StartsWith("Starting manager: ") && message.Content.Split(": ") is string[] args)
                    {
                        managers.Add(new() 
                        { 
                            Name = args[1].Split(',')[0],
                            ContextId = message.ContextId,
                            Status = ManagerStatus.Running,
                            ExecutionId = message.ExecutionId,
                        });
                    }
                }
            }
            return new(messages, managers, executions);
        }

        /// <summary>
        /// Creates a <see cref="LogMessage"/> from the specified <see cref="LoggingEntry"/>.
        /// </summary>
        /// <param name="entry">The raw entry to parse.</param>
        /// <returns>A log message that is stripped of any color coding and has a <see cref="LogMessageType"/>.</returns>
        private LogMessage GetParsedLogMessage(LoggingEntry entry)
        {
            string content = Regex.Replace(entry.LogMessage, @"\u001b\[\d*;?\d+m", ""); // Removes color coding which makes it harder to parse the text later
            LogMessageType type = GetLogMessageType(entry, content);
            int contextId = (int)entry.ContextId.Value;
            int executionId = (int)entry.ExecutionId.Value;
            DateTime date = entry.Created.Value;
            return new LogMessage(content, type, contextId, executionId, date);
        }

        /// <summary>
        /// Gets the <see cref="LogMessageType"/> associated with the specified content of an entry.
        /// </summary>
        /// <param name="entry">The entry to get the type of.</param>
        /// <param name="content">The content of the entry, stripped of any color coding.</param>
        /// <returns>A <see cref="LogMessageType"/> with all flags that suit the given logging entry.</returns>
        private LogMessageType GetLogMessageType(LoggingEntry entry, string content)
        {
            var type = entry.LogLevel switch
            {
                "INFO" => LogMessageType.Info,
                "WARN" => LogMessageType.Warning,
                "ERROR" => LogMessageType.Error,
                "FATAL" => LogMessageType.Fatal,
                _ => LogMessageType.None,
            };
            if (content.StartsWith("Afstemning") || content.StartsWith("Check -"))
            {
                // Since the enum is actually a bitflag, we can add several types to it.
                // In this case, we want failed validations to not only be parsed as errors, but also as validations.
                if (type.HasFlag(LogMessageType.Error))
                {
                    type |= LogMessageType.Validation; // Adds the flag
                }
                else
                {
                    type = LogMessageType.Validation; // Sets the flag
                }
            }
            return type;
        }
    }
}
